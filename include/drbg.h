#include <openssl/rand.h>
#include <openssl/evp.h>
#include <openssl/core_names.h>
#include <openssl/params.h>
#include <openssl/provider.h>
#include <string.h>


#define STR_EQUAL(a, b) (0 == strcmp(a, b))
#define MIN(a, b) (a > b ? b : a)

/* Lets use 'byte' instead of 'char' */
typedef char byte;

#define DEFAULT_STRENGTH 128

typedef struct DRBGParams {
    int prediction_resistance;
    int strength;
    byte *additional_data;
    int additional_data_length;
    byte *personalization_str;
    int personalization_str_len;
} DRBGParams;

/* Group everything related to an EVP_RAND into this struct */ 
typedef struct _DRBG {
    byte* seed;
    EVP_RAND_CTX* context;
    struct _DRBG* parent;
    DRBGParams *drbg_params;
} DRBG;

/* Fetch and initialize a DRBG instance */
DRBG* create_DRBG(const char* name, DRBG* parent);

DRBG* create_DRBG_with_params(const char *name, DRBG *parent, DRBGParams *params);

/* Destroy the given DRBG */
int destroy_DRBG(DRBG* generator);

/* Generate a seed of size n_bytes
 * If a parent EVP_RAND was used, generate a seed (bytes) using it
 * If not, call getentropy() :-(
 */
int generate_seed(DRBG* generator, byte output[], int n_bytes);

/* Reseed the DRBG with a given seed
 * Passing seed = NULL will force reseeding using the
 * underlying entropy source
 */

void reseed(DRBG* generator);

void reseed_with_seed(DRBG* generator, byte seed[], int seed_length);

void reseed_with_seed_and_params(DRBG* generator, byte seed[], int seed_length, DRBGParams *params);

/* Return the next random integer generated by the DRBG.
 * num_bits is the size of the integer in bits
 */
int next_rand_int(DRBG* generator, int num_bits);

/* Return the next requested number of random bytes generated by the DRBG */
int next_rand(DRBG* generator, byte output[], int n_bytes);

int next_rand_with_params(DRBG *generator, byte output[], int n_bytes, DRBGParams *params);
