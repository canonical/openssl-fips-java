#include <openssl/rand.h>
#include <openssl/evp.h>
#include <openssl/core_names.h>
#include <openssl/params.h>
#include <openssl/provider.h>
#include <string.h>

#define STR_EQUAL(a, b) (0 == strcmp(a, b))

/* Lets use 'byte' instead of 'char' */
typedef char byte;

/* Group everything related to an EVP_RAND into this struct */ 
typedef struct _DRBG {
    byte* seed;
    EVP_RAND_CTX* context;
    int strength;
} DRBG;

/* Fetch and initialize a DRBG instance */
DRBG* create_DRBG(const char* name);

/* Destroy the given DRBG */
int destroy_DRBG(DRBG* generator);

/* If a seed isn't created yet, generate one.
 * If it is, just delegate to get_seed(DRBG*, int)
 */
int generate_seed(DRBG* generator, byte output[], int n_bytes);

/* Return the generated seed. 
 * TODO: what do I return if a seed isn't generated yet?
 */
byte* get_seed(DRBG* generator, int n_bytes);

/* Reseed the DRBG with a given seed
 * Passing seed = NULL will force reseeding using the
 * underlying entropy source
 */
void reseed(DRBG* generator, byte seed[]);

/* Return the next random integer generated by the DRBG */
int next_rand_int(DRBG* generator);

/* Return the next requested number of random bytes generated by the DRBG */
int next_rand(DRBG* generator, byte output[], int n_bytes);
